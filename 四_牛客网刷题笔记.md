# 牛客网刷题笔记

[TOC]

## 初阶

1. 使用`COUNT`等函数需要用`GROUP BY`

2. `GROUP BY` 后面要接 `HAVING`

3. `COUNT()` 可以用多个条件

   ```sql
   '计算2021年每个月里试卷作答区用户平均月活跃天数avg_active_days和月度活跃人数mau'
   
   SELECT
       DATE_FORMAT(submit_time, '%Y%m') AS monthtime,
       ROUND(COUNT(DISTINCT uid, date_format(submit_time,'%Y%m%d'))/COUNT(DISTINCT uid),2) AS avg_active_days,
       '这里count要用2个条件，且要按天数来确定'
       COUNT(DISTINCT uid) AS mau
   FROM    
       exam_record
   WHERE  
       submit_time IS NOT NULL AND 
       year(submit_time) = 2021
   GROUP BY
       monthtime
   ```

4. 子查询应该返回单一的标量值（单个列或计算结果），但你在子查询中试图返回两列（`prod_id` 和 `SUM(quantity)`），这在 `SELECT` 子句中是不允许的。.

5. `Limit` 可以用在查询也可以用在删除

6. 全部删除（表清空，包含自增计数器重置）：`TRUNCATE tb_name`

## 合并查询

1. `JOIN`时候，多个表同一个字段，要明确表明字段来自哪个表，尽管名字一样。加上`xxx.id = yyy.id` or `USING(xxx)`。
2. `Union All` 合并查询不去重，可以用两个`SELECT`
3. 所有 `SELECT` 列表中的列要么必须在 `GROUP BY` 中列出，要么必须是聚合函数的结果
4. SQL 的逻辑是先根据 `JOIN` 条件将表合并，然后再应用 `WHERE` 条件。
5. 用`WHERE XX.ID = YY.ID`， 只能完全匹配，没匹配上的不算。`JOIN` 函数如果没匹配上还存在。

## 日期相关

1. `TIMESTAMPDIFF(interval, time_start, time_end)`可计算`time_start-time_end`的时间差，单位以指定的`interval`为准，常用可选：

   - SECOND 秒
   - MINUTE 分钟（返回秒数差除以60的整数部分）
   - HOUR 小时（返回秒数差除以3600的整数部分）
   - DAY 天数（返回秒数差除以3600*24的整数部分）
   - MONTH 月数
   - YEAR 年数

2. `LAG(date, 1) OVER (PARTITION BY device_id ORDER BY date)`  --- 还有`LEAD（）`

3. **日期处理`LEAD(date, 1)`后一天，`LAG(date, 1)前一天`，`DATE_ADD(date, INTERVAL 1 DAY) `后一天，`DATE_SUB(date, INTERVAL 1 DAY) 前一天

   ```sql
   SELECT
       SUM(dayafter = DATE_ADD(date, INTERVAL 1 DAY)) / COUNT(*) AS ratio
   FROM 
   (
       SELECT
           device_id,
           date,
           LEAD(date, 1) OVER (PARTITION BY device_id ORDER BY date) AS dayafter
       FROM
           question_practice_detail
       GROUP BY device_id, date
   ) AS subquery;
   
   
   提取年和月（返回 2021-09）: 使用 DATE_FORMAT() 函数，可以将时间戳格式化为 年-月 格式。
   MySQL(牛客):
   SELECT DATE_FORMAT('2021-09-07 10:01:01', '%Y-%m') AS year_month;
   SELECT DATE_FORMAT('2021-09-07 10:01:01', '%Y-%m-%d') AS year_month_day;
   
   ```

3. 案例

   ```sql
   '现在运营想要了解复旦大学的每个用户在8月份练习的总题目数和回答正确的题目数情况，请取出相应明细数据，对于在8月份没有练习过的用户，答题数结果返回0.'
   SELECT
       UP.device_id, 
       UP.university,
       -- COALESCE(XX, 0) AS xxx 将NULL变为0
       COALESCE(count(QPD.question_id), 0) AS question_cnt,
       COALESCE(sum(if(QPD.result = 'right', 1, 0)), 0) AS right_question_cnt
   FROM    
       user_profile AS UP
   LEFT JOIN
       question_practice_detail AS QPD
   ON
       UP.device_id = QPD.device_id 
       AND month(QPD.date) = 8  -- 将月份的限制移到这里，确保所有用户都被考虑
   WHERE 
       UP.university = '复旦大学'
   GROUP BY    
       UP.device_id;
   
   ```

## 文本处理

1. 分词

   ```sql
   SELECT  
      SUBSTRING_INDEX(profile, ',', -1) AS gender, count(*) AS number
   FROM
     user_submit
   GROUP BY  
     gender
     
   # SUBSTRING_INDEX(SUBSTRING_INDEX(profile, ',', -2), ',', 1) AS age
   
   #正则表达式
   SELECT 
       REGEXP_SUBSTR(column_name, '[^,]+$', 1, 1) AS after_comma
   FROM 
       table_name;
   """
   语法结构：
   REGEXP_SUBSTR(profile, '[^,]+(?=,[^,]+$)') AS age
   
   REGEXP_SUBSTR(string, pattern, start_position, occurrence)
   string: 要在其中搜索模式的字符串列或字符串常量。
   pattern: 正则表达式模式，用于匹配所需的子字符串。
   start_position: 搜索开始的位置，默认是1，即从字符串的第一个字符开始。
   occurrence: 表示你想要返回匹配项的第几次出现，默认值是1。
   具体参数解释：
   [^,]+: 这个是正则表达式模式，表示匹配除逗号以外的一个或多个字符。[^,] 表示“不是逗号的字符”，+表示匹配一次或多次。
   $: 表示匹配字符串的末尾，这意味着模式会从字符串的末尾开始查找。
   因此，[^,]+$ 的意思是匹配最后一个逗号之后的所有字符，直到字符串的末尾。
   
   1: 表示从字符串的第一个字符开始搜索。这个参数在这里作用不大，因为模式已经决定了匹配从字符串末尾开始。
   1: 表示提取第一个匹配到的子字符串（即最后一个逗号之后的内容）。
   """
   ```

2. 在 SQL 中，`%` 是一个通配符，用于表示任意数量的字符（包括零个字符）。在你的查询中，`LIKE '%toy'` 表示匹配以 "toy" 结尾的文本，而 `LIKE '%carrots'` 表示匹配以 "carrots" 结尾的文本。

3. 字符处理

   ```sql
   -- 将字符串中的所有字符转换为大写
   SELECT UPPER('hello world') AS upper_text;
   -- 将字符串中的所有字符转换为小写
   SELECT LOWER('HELLO WORLD') AS lower_text;
   -- 将字符串中每个单词的首字母转换为大写（部分数据库支持）
   SELECT INITCAP('hello world') AS capitalized_text;
   -- 去除字符串开头的空格或指定字符
   SELECT LTRIM('   Hello World') AS trimmed_text;
   -- 去除字符串结尾的空格或指定字符
   SELECT RTRIM('Hello World   ') AS trimmed_text;
   -- 去除字符串两端的空格或指定字符
   SELECT TRIM('   Hello World   ') AS trimmed_text;
   -- 截取字符串中的指定子字符串
   SELECT SUBSTRING('Hello World', 1, 5) AS substring_text;
   -- 将多个字符串连接成一个字符串
   SELECT CONCAT('Hello', ' ', 'World') AS concatenated_text;
   -- 替换字符串中指定的子字符串
   SELECT REPLACE('Hello World', 'World', 'SQL') AS replaced_text;
   -- 返回字符串的字符数
   SELECT LENGTH('Hello World') AS text_length;
   -- 从字符串的左边提取指定数量的字符
   SELECT LEFT('Hello World', 5) AS left_text;
   -- 从字符串的右边提取指定数量的字符
   SELECT RIGHT('Hello World', 5) AS right_text;
   -- 返回子字符串在字符串中首次出现的位置
   SELECT INSTR('Hello World', 'World') AS position;
   -- 在字符串的左边填充指定字符，使其达到指定的总长度
   SELECT LPAD('123', 5, '0') AS padded_text;
   -- 在字符串的右边填充指定字符，使其达到指定的总长度
   SELECT RPAD('123', 5, '0') AS padded_text;
   
   ```

## 预编程 

 1. 生成变量

    ```sql
    '生成一条 SQL 语句，用于删除数据库中所有符合条件的表'
    
    SELECT 
        -- 使用 CONCAT 函数连接字符串，生成类似于 'DROP TABLE IF EXISTS table1, table2, ...;' 的 SQL 语句
        CONCAT('DROP TABLE IF EXISTS ', GROUP_CONCAT(' ', TABLE_NAME), ';') AS sqltext 
        -- 将生成的 SQL 语句存储在用户变量 @sqltext 中
        INTO @sqltext 
    FROM 
        -- 查询 MySQL 的 INFORMATION_SCHEMA 表，获取所有表的信息
        information_schema.TABLES 
    WHERE 
        -- 只选择表名以 'exam_record_201_' 开头的表
        TABLE_NAME LIKE 'exam_record_201_' 
        -- 进一步筛选，确保表名的第13到16个字符（即年份部分）在 2011 和 2014 之间。SUBSTR() 是一个字符串函数，用于从指定位置开始截取字符串中的一部分。具体语法为 SUBSTR(string, start_position, length)。
        AND SUBSTR(TABLE_NAME, 13, 4) BETWEEN 2011 AND 2014;
    
    -- 准备并解析 @sqltext 中的动态 SQL 语句
    PREPARE stmt FROM @sqltext;
    
    -- 执行准备好的 SQL 语句，删除符合条件的表
    EXECUTE stmt;
    
    -- 释放准备好的 SQL 语句，以节省资源
    DEALLOCATE PREPARE stmt;
    ```

## 函数

1. 截断平均值

   ```sql
   '匹配表格后计算截断平均值(去掉最大和最小)'
   
   WITH ranked_scores AS (
       SELECT
           er.score,
           ei.tag,
           ei.difficulty,
           ROW_NUMBER() OVER (ORDER BY er.score ASC) AS rn_asc,
           ROW_NUMBER() OVER (ORDER BY er.score DESC) AS rn_desc
       FROM
           exam_record er
       LEFT JOIN
           examination_info ei ON er.exam_id = ei.exam_id
       WHERE
           ei.tag = 'SQL' AND
           ei.difficulty = 'hard' AND
           er.score IS NOT NULL
   )
   SELECT
       tag,
       difficulty,
       ROUND(AVG(score),1) AS avg_score
   FROM
       ranked_scores
   WHERE
       rn_asc > 1 AND rn_desc > 1
   GROUP BY
       tag, difficulty;
   ```

2. 子查询 

   ```sql
   '统计出总作答次数total_pv、试卷已完成作答数complete_pv、已完成的试卷数complete_exam_cnt。'
   '子查询案例1'
   SELECT 
       count(uid) AS total_pv,
       (SELECT count(submit_time) FROM exam_record WHERE submit_time IS NOT NULL ) AS complete_pv,
       (SELECT count(DISTINCT exam_id) FROM exam_record WHERE submit_time IS NOT NULL) AS complete_exam_cnt
   FROM
       exam_record
   
   '子查询案例2'
   请从试卷作答记录表中找到SQL试卷得分不小于该类试卷平均得分的用户最低得分。
   示例数据 exam_record表（uid用户ID, exam_id试卷ID, start_time开始作答时间, submit_time交卷时间, score得分）：
   SELECT
       MIN(er.score) AS min_score_over_avg
   FROM
       exam_record er
   LEFT JOIN 
       examination_info ei
       USING(exam_id)
   WHERE
       ei.tag = 'SQL' AND
       er.score IS NOT NULL AND
       er.score >= (
           SELECT AVG(er2.score)
           FROM exam_record er2
           LEFT JOIN examination_info ei2
           ON er2.exam_id = ei2.exam_id
           WHERE ei2.tag = 'SQL'
       );
   ```

3. case when的用法

   ```sql
   '统计出总作答次数total_pv、试卷已完成作答数complete_pv、已完成的试卷数complete_exam_cnt。'
   
   'CASE WHEN 案例'   
   select
       count(*) as total_pv,
       count(case when score is not null then 1 else null end) as complete_pv,
       count(distinct case when score is not null then exam_id else null end) as complete_exam_cnt
   from exam_record ;
   ```

   